// **************************************************************************
// File       [ simulator.cpp ]
// Author     [ littleshamoo ]
// Synopsis   [ ]
// Date       [ 2011/09/14 created ]
// **************************************************************************

#include "simulator.h"

using namespace std;
using namespace IntfNs;
using namespace CoreNs;

// **************************************************************************
// Function   [ ppGoodSim ]
// Commentor  [ Bill ]
// Synopsis   [ usage: for each pattern generated,
//					   apply them separately and run good circuit simulation 
//              in:    all the patterns generated by atpg
//              out:   void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppGoodSim(PatternProcessor *)
void Simulator::ppGoodSim(PatternProcessor *pcoll) {
    for (int i = 0; i < (int)pcoll->pats_.size(); i += WORD_SIZE) {
        ppSetPattern(pcoll, i);
        goodSim();
    }
} //}}}

// **************************************************************************
// Function   [ Simulator::eventFaultSim ]	
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: call faultEval function whose gate's ID in 
//                     stack event and check faulty value is equal to good 
//                     value or not 
//                     If the values are the same, no more process is needed
//                     If the values are not the same, keep processing
//              in:    void
//              out:   void
//            ]
// Date       [ CJY Ver. 1.0 started 2013/08/14 ]
// **************************************************************************
//{{{ void Simulator::eventFaultSim()
void Simulator::eventFaultSim() {
    for (int i = 0; i < cir_->tlvl_; ++i) {
        while (!events_[i].empty()) {
            int gid = events_[i].top();  //get gate's ID
            events_[i].pop();
            processed_[gid] = false;
            faultEval(gid);
            recover_[nrecover_] = gid;   //record gate's ID
            nrecover_++;

            //check whether faulty value and good value are equal
            if (cir_->gates_[gid].fl_ == cir_->gates_[gid].gl_
                && cir_->gates_[gid].fh_ == cir_->gates_[gid].gh_)
                continue;

            //if not equal and flag = false. set flag true
            for (int j = 0; j < cir_->gates_[gid].nfo_; ++j) {
                int foid = cir_->gates_[gid].fos_[j];
                if (processed_[foid])
                    continue;
                events_[cir_->gates_[foid].lvl_].push(foid);
                processed_[foid] = true;
            }
        }
    }
} //}}}

// **************************************************************************
// Function   [ void Simulator::pfFaultSim(PatternProcessor *, FaultListExtract *) ]
// Author     [ littleshamoo ]
// Synopsis   [ usage: perform parallel fault simulation on all patterns. 
//					   call pfFaultSim(FaultList &remain) for each pattern
//				in:	   a set of pattern
//				out:   void
//			  ]
// Date       [ ]
// **************************************************************************
//{{{ void Simulator::pfFaultSim(PatternProcessor *, FaultListExtract *)
void Simulator::pfFaultSim(PatternProcessor *pcoll, FaultListExtract *fListExtract) {
    // undetected faults are remaining faults
    FaultList remain;
    FaultListIter it = fListExtract->current_.begin();
    for ( ; it != fListExtract->current_.end(); ++it)
        if ((*it)->state_ != Fault::DT && (*it)->state_ != Fault::RE && (*it)->line_ >= 0)
            remain.push_back(*it);

    // simulate all patterns for all faults
    for (size_t i = 0; i < pcoll->pats_.size(); ++i) {
        if (remain.size() == 0)
            break;
	
		// Assign pattern to circuit PI & PPI for further fault sim
		assignPatternToPi( pcoll->pats_[i] );
        pfFaultSim(remain);
    }

} //}}}

// **************************************************************************
// Function   [ Simulator::pfFaultSim ]
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: set pattern. call pfFaultSim(FaultList &remain) 
//                     to do faultsim for this pattern
//              in:    one pattern , FaultList contain undetected faults
//              out:   void
//            ]
// Date       [ CJY Ver. 1.0 started 2013/08/14 ]
// **************************************************************************
//{{{ void Simulator::pfFaultSim(const Pattern * const, FaultList &)
int Simulator::pfFaultSim(const Pattern * const p, FaultList &remain) {

	// Assign pattern to circuit PI & PPI for further fault sim
	assignPatternToPi( p );
    
    return pfFaultSim(remain);

} 

int Simulator::pfFaultSim(const Pattern * const p, 
                          FaultVec &detect, 
                          FaultList &remain) { 

    detect.clear(); 

	// Assign pattern to circuit PI & PPI for further fault sim
	assignPatternToPi( p );
    
    return pfFaultSim(detect, remain);
}//}}}

// **************************************************************************
// Function   [ Simulator::pfFaultSim ]	
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: do faultsim for the fault in fault list
//              in:    FaultList ( = list<Fault *> ) contains undetected faults
//              out:   void
//            ]
// Date       [ CJY Ver. 1.0 started 2013/08/14 ]
// **************************************************************************
//{{{ void Simulator::pfFaultSim(FaultList &)
int Simulator::pfFaultSim(FaultList &remain) {
    if (remain.size() == 0)
        return 0;

    int ret = 0; 

    // run good simulation first
    goodSimCopyToFault();

    // inject number of WORD_SIZE activated faults
    //size_t i = 0;
    //pfReset();
    FaultListIter it = remain.begin();
    do {
        // if fault is activated, inject fault
        if (pfCheckActivation(*it)) {
            pfInject(*it, ninjected_);
            injected_[ninjected_] = it;
            ninjected_++;
        }
        it++;

        // run fault sim if enough fault or end of fault list
        if (ninjected_ == (int)WORD_SIZE
            || (it == remain.end() && ninjected_ > 0)) {
            eventFaultSim();
            ret+=pfCheckDetection(remain);
            pfReset();
        }

    } while (it != remain.end());

    return ret; 
} 

int Simulator::pfFaultSim(FaultVec &detect, FaultList &remain) { 
    if (remain.size() == 0)
        return 0;

    int ret = 0; 

    // run good simulation first
    goodSimCopyToFault();

    // inject number of WORD_SIZE activated faults
    //size_t i = 0;
    //pfReset();
    FaultListIter it = remain.begin();
    do {
        // if fault is activated, inject fault
        if (pfCheckActivation(*it)) {
            pfInject(*it, ninjected_);
            injected_[ninjected_] = it;
            ninjected_++;
        }
        it++;

        // run fault sim if enough fault or end of fault list
        if (ninjected_ == (int)WORD_SIZE
            || (it == remain.end() && ninjected_ > 0)) {
            eventFaultSim();
            ret+=pfCheckDetection(detect, remain);
            pfReset();
        }

    } while (it != remain.end());

    return ret; 

} //}}}

// **************************************************************************
// Function   [ Simulator::pfCheckActivation ]	
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: check whether the fault can be activate to the fanout of the gate
//                     ie, compare good low & high with the fault type
//              in:    address of fault to be tested
//              out:   bool
//            ]
// Date       [ CBH Ver. 1.0 started 2013/08/18 ]
// **************************************************************************
//{{{ bool Simulator::pfCheckActivation(const Fault * const)
bool Simulator::pfCheckActivation(const Fault * const f) {
    const int &fg = f->line_ == 0 ? f->gate_ :
                                    cir_->gates_[f->gate_].fis_[f->line_ - 1];
    const ParaValue &gl = cir_->gates_[fg].gl_;
    const ParaValue &gh = cir_->gates_[fg].gh_;

    switch (f->type_) {
        case Fault::SA0:
            return gh != PARA_L;
            break;
        case Fault::SA1:
            return gl != PARA_L;
            break;
        case Fault::STR:
            if (cir_->nframe_ < 2)
                return false;
            return (gl & cir_->gates_[fg + cir_->ngate_].gh_) != PARA_L;
            break;
        case Fault::STF:
            if (cir_->nframe_ < 2)
                return false;
            return (gh & cir_->gates_[fg + cir_->ngate_].gl_) != PARA_L;
            break;
        default:
            break;
    }
    return false;
} //}}}

// **************************************************************************
// Function   [ simulator::pfInject ]
// Commentor  [ CJY CBH]
// Synopsis   [ usage: push faulty gate to event list
//              in:    fault, index of injected fault
//              out:   void
//            ]
// Date       [ CBH Ver. 1.0 started 2031/08/18 ]
// **************************************************************************
//{{{ void Simulator::pfInject(const Fault * const , const size_t &)
void Simulator::pfInject(const Fault * const f, const size_t &i) {
    int fg = f->gate_;
    switch (f->type_) {
        case Fault::SA0:
            setBitValue(faultInjectL_[fg][f->line_], i, H);
            break;
        case Fault::SA1:
            setBitValue(faultInjectH_[fg][f->line_], i, H);
            break;
        case Fault::STR:
            fg += cir_->ngate_;
            setBitValue(faultInjectL_[fg][f->line_], i, H);
            break;
        case Fault::STF:
            fg += cir_->ngate_;
            setBitValue(faultInjectH_[fg][f->line_], i, H);
            break;
        default:
            break;
    }

    // put gate into event list
    if (!processed_[fg]) {
        events_[cir_->gates_[fg].lvl_].push(fg);
        processed_[fg] = true;
    }
} //}}}

// **************************************************************************
// Function   [ simulator::pfCheckDetection ]
// Commentor  [ CJY CBH]
// Synopsis   [ usage: compare the good sim and fault sim result
//					   and check whether the injected fault can be detected by the  pattern
//              in:    the list of undetected fault
//              out:   void
//            ]
// Date       [ CBH Ver. 1.0 started 2031/08/18 ]
// **************************************************************************
//{{{ void Simulator::pfCheckDetection(FaultList &)
int Simulator::pfCheckDetection(FaultList &remain) {
    int ret = 0; 
    ParaValue detected = PARA_L;
    int start = cir_->tgate_ - cir_->npo_ - cir_->nppi_;
    for (int i = start; i < cir_->tgate_; ++i)
        detected |= ((cir_->gates_[i].gl_ & cir_->gates_[i].fh_)
                   | (cir_->gates_[i].gh_ & cir_->gates_[i].fl_));

    // fault drop
    for (int i = 0; i < ninjected_; ++i) {
        if (getBitValue(detected, (size_t)i) == L)
            continue;
        (*injected_[i])->det_++;
        if ((*injected_[i])->det_ >= ndet_) {
            if ((*injected_[i])->state_==Fault::DH 
              || (*injected_[i])->state_==Fault::AB 
              || (*injected_[i])->state_==Fault::AH) 
                (*injected_[i])->state_ = Fault::DH;
            else if ((*injected_[i])->state_==Fault::PT)  
                (*injected_[i])->state_ = Fault::PT;
            else if ((*injected_[i])->state_==Fault::AU) { 
                // TODO: assert after debug 
                (*injected_[i])->print(); 
                (*injected_[i])->state_ = Fault::PT;
            }
            else 
                (*injected_[i])->state_ = Fault::DT;

            remain.erase(injected_[i]);
            ret++; 
        }
    }

    return ret; 
} 

int Simulator::pfCheckDetection(FaultVec &detect, FaultList &remain) { 
    int ret = 0; 
    ParaValue detected = PARA_L;
    int start = cir_->tgate_ - cir_->npo_ - cir_->nppi_;
    for (int i = start; i < cir_->tgate_; ++i)
        detected |= ((cir_->gates_[i].gl_ & cir_->gates_[i].fh_)
                   | (cir_->gates_[i].gh_ & cir_->gates_[i].fl_));

    // fault drop
    for (int i = 0; i < ninjected_; ++i) {
        if (getBitValue(detected, (size_t)i) == L)
            continue;
        (*injected_[i])->det_++;
        if ((*injected_[i])->det_ >= ndet_) {
            if ((*injected_[i])->state_==Fault::DH 
              || (*injected_[i])->state_==Fault::AB 
              || (*injected_[i])->state_==Fault::AH) 
                (*injected_[i])->state_ = Fault::DH;
            else if ((*injected_[i])->state_==Fault::PT)  
                (*injected_[i])->state_ = Fault::PT;
            else if ((*injected_[i])->state_==Fault::AU) { 
                // TODO: assert after debug 
                (*injected_[i])->print(); 
                (*injected_[i])->state_ = Fault::PT;
            }
            else 
                (*injected_[i])->state_ = Fault::DT;

            detect.push_back(*injected_[i]); 
            remain.erase(injected_[i]);
            ret++; 
        }
    }

    return ret; 
} //}}}

// **************************************************************************
// Function   [ void Simulator::ppFaultSim(PatternSet *, FaultListExtract *) ]
// Author     [ littleshamoo ]
// Synopsis   [ usage: perform parallel pattern simulation on all faults. 
//				in:    a set of pattern, FaultListExtract
//				out:   void
//			  ]
// Date       [ ]
// **************************************************************************
//{{{ void Simulator::ppFaultSim(PatternProcessor *, FaultListExtract *)
void Simulator::ppFaultSim(PatternProcessor *pcoll, FaultListExtract *fListExtract) {
    // undetected faults are remaining faults
    FaultList remain;
    FaultListIter it = fListExtract->current_.begin();
    for ( ; it != fListExtract->current_.end(); ++it)
        if ((*it)->state_ != Fault::DT && (*it)->state_ != Fault::RE && (*it)->line_ >= 0)
            remain.push_back(*it);

    // simulate all patterns for all faults
    for (int i = 0; i < (int)pcoll->pats_.size(); i += WORD_SIZE) {
        ppSetPattern(pcoll, i);
        ppFaultSim(remain);
    }
} //}}}

// **************************************************************************
// Function   [ Simulator::ppFaultSim ]
// Commentor  [ Bill ]
// Synopsis   [ usage: simulate all undetected faults
//              in:    a set of undetected fault
//              out:   void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppFaultSim(FaultList &)
void Simulator::ppFaultSim(FaultList &remain) {
    if (remain.size() == 0)
        return;

    // run good simulation first
    goodSimCopyToFault();

    FaultListIter it = remain.begin();
    do {
        if (ppCheckActivation((*it))) {
            ppInject((*it));
            eventFaultSim();
            ppCheckDetection((*it));
            ppReset();
        }
        if ((*it)->state_ == Fault::DT)
            it = remain.erase(it);
        else
            it++;
    } while (it != remain.end());
} //}}}

// **************************************************************************
// Function   [ ppCheckActivation ]
// Commentor  [ Bill ]
// Synopsis   [ usage: check whether the fault can be activate to the fanout of the gate
//              in:    fault to be tested
//              out:   bool
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ bool Simulator::ppCheckActivation(const Fault * const)
bool Simulator::ppCheckActivation(const Fault * const f) {
    const int &fg = f->line_ == 0 ? f->gate_ :///if output fault,fg=ID of the faulty gate,else if input fault,fg=ID of the faulty gate's fanin array
                                    cir_->gates_[f->gate_].fis_[f->line_ - 1];
    const ParaValue &gl = cir_->gates_[fg].gl_;
    const ParaValue &gh = cir_->gates_[fg].gh_;

    switch (f->type_) {
        case Fault::SA0:
            activated_ = gh;
            return activated_ != PARA_L;
            break;
        case Fault::SA1:
            activated_ = gl;
            return activated_ != PARA_L;
            break;
        case Fault::STR:
            if (cir_->nframe_ < 2)
                return false;
            activated_ = (gl & cir_->gates_[fg + cir_->ngate_].gh_);
            return activated_ != PARA_L;
            break;
        case Fault::STF:
            if (cir_->nframe_ < 2)
                return false;
            activated_ = (gh & cir_->gates_[fg + cir_->ngate_].gl_);
            return activated_ != PARA_L;
            break;
        default:
            break;
    }
    return false;
} //}}}

// **************************************************************************
// Function   [ ppInject ]
// Commentor  [ Bill ]
// Synopsis   [ usage: inject fault 
//              in:    a fault to be injected
//              out:   void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppInject(const Fault * const)
void Simulator::ppInject(const Fault * const f) {
    int fg = f->gate_;
    switch (f->type_) {
        case Fault::SA0:
            faultInjectL_[fg][f->line_] = PARA_H;
            break;
        case Fault::SA1:
            faultInjectH_[fg][f->line_] = PARA_H;
            break;
        case Fault::STR:
            fg += cir_->ngate_;
            faultInjectL_[fg][f->line_] = PARA_H;
            break;
        case Fault::STF:
            fg += cir_->ngate_;
            faultInjectH_[fg][f->line_] = PARA_H;
            break;
        default:
            break;
    }

    // put gate into event list
    if (!processed_[fg]) {
        events_[cir_->gates_[fg].lvl_].push(fg);
        processed_[fg] = true;
    }
} //}}}

// **************************************************************************
// Function   [ ppCheckDetection ]
// Commentor  [ Bill ]
// Synopsis   [ usage: compare the good sim and fault sim result
//					   and check whether the injected fault can be detected by the  pattern
//              in:    a fault which is injected into the circuit
//              out:   void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppCheckDetection(Fault * const)
void Simulator::ppCheckDetection(Fault * const f) {
    ParaValue detected = PARA_L;
    int start = cir_->tgate_ - cir_->npo_ - cir_->nppi_;
    for (int i = start; i < cir_->tgate_; ++i)
        detected |= ((cir_->gates_[i].gl_ & cir_->gates_[i].fh_)
                   | (cir_->gates_[i].gh_ & cir_->gates_[i].fl_));
    detected &= activated_;

    // fault drop
    for (size_t i = 0; i < WORD_SIZE; ++i) {
        if (getBitValue(detected, i) == L)
            continue;
        f->det_++;
        if (f->det_ >= ndet_) {
            f->state_ = Fault::DT;
            break;
        }
    }
} //}}}

// **************************************************************************
// Function   [ ppSetPattern ]
// Commentor  [ Bill ]
// Synopsis   [ usage: apply pattern
//              in:    the total pattern set, 
//					   and an integer to represent the starting pattern of current fsim
//              out:   void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppSetPattern(PatternProcessor *, const int &)
void Simulator::ppSetPattern(PatternProcessor *pcoll, const int &i) { //TODO LOS not yet supported 
    // reset PI and PPI values to unknowns
    for (int j = 0; j < cir_->npi_ + cir_->nppi_; ++j) {       
        for (int k = 0; k < cir_->nframe_; ++k) {               
            cir_->gates_[j + k * cir_->ngate_].gl_ = PARA_L;   
            cir_->gates_[j + k * cir_->ngate_].gh_ = PARA_L;
        }
    }

    // assign up to WORD_SIZE number of pattern values
    int endpat = (int)pcoll->pats_.size();
    if (i + (int)WORD_SIZE <= (int)pcoll->pats_.size())
        endpat = i + WORD_SIZE;
    for (int j = i; j < endpat; ++j) {
        // assign PI
        if (pcoll->pats_[j]->pi1_) {
            for (int k = 0; k < pcoll->npi_; ++k) {
                if (pcoll->pats_[j]->pi1_[k] == L)
                    setBitValue(cir_->gates_[k].gl_, j - i, H);
                else if (pcoll->pats_[j]->pi1_[k] == H)
                    setBitValue(cir_->gates_[k].gh_, j - i, H);
            }
        }
        if (pcoll->pats_[j]->pi2_ && cir_->nframe_ > 1) {
            for (int k = 0; k < pcoll->npi_; ++k) {
                int index = k + cir_->ngate_;
                if (pcoll->pats_[j]->pi2_[k] == L)
                    setBitValue(cir_->gates_[index].gl_, j - i, H);
                else if (pcoll->pats_[j]->pi2_[k] == H)
                    setBitValue(cir_->gates_[index].gh_, j - i, H);
            }
        }
        // assign PPI
        if (pcoll->pats_[j]->ppi_) {
            for (int k = 0; k < pcoll->nppi_; ++k) {
                int index = k + cir_->npi_;
                if (pcoll->pats_[j]->ppi_[k] == L)
                    setBitValue(cir_->gates_[index].gl_, j - i, H);
                else if (pcoll->pats_[j]->ppi_[k] == H)
                    setBitValue(cir_->gates_[index].gh_, j - i, H);
            }
        }

        if (pcoll->pats_[j]->si_ && cir_->nframe_ > 1 && cir_->connType_ == Circuit::SHIFT) {
			int index = cir_->ngate_ + cir_->npi_;
			if (pcoll->pats_[j]->si_[0] == L)
				setBitValue(cir_->gates_[index].gl_, j - i, H);
			else if (pcoll->pats_[j]->si_[0] == H)
				setBitValue(cir_->gates_[index].gh_, j - i, H);
        }
    }
} //}}}
